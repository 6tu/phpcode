GHS代理PHP简版

不知道为什么，我一用HTTP/1.1发送请求，GHS代理就慢得要死。即是改用HTTP/1.0发送请求，如果把服务器端的Header转发 给用户，照样慢的要死。不知道是怎么回事，所以只好写出这个只具备一般浏览功能，连POST都不支持，更别说301转向之类的GHS代理的PHP版本。
采用fsockopen获取数据。

首先，把绑在GHS的域名绑到某PHP空间，并将实际DNS指向该PHP空间。该空间需要支持.htaccess和URL ReWrite。

然后，把下面内容保存为index.php，传到根目录：

<?php//header不完整，强制为HTTP 1.0$ghslist=array("72.14.203.121","72.14.207.121","74.125.43.121","74.125.47.121","74.125.53.121","74.125.77.121","74.125.93.121","74.125.95.121","74.125.113.121","216.239.32.21","216.239.34.21","216.239.36.21","216.239.38.21",);$ghsnum=rand(0,count($ghslist));//set_time_limit(600);//error_reporting(0); //禁止显示错误//取得所有http headerif (!function_exists('getallheaders')){    function getallheaders()    {       foreach ($_SERVER as $name => $value)       {           if (substr($name, 0, 5) == 'HTTP_')           {               $headers[str_replace(' ', '-', ucwords(strtolower(str_replace('_', ' ', substr($name, 5)))))] = $value;           }       }       if (isset($_SERVER['PHP_AUTH_DIGEST'])) {		    $headers['AUTHORIZATION'] = $_SERVER['PHP_AUTH_DIGEST'];			} elseif (isset($_SERVER['PHP_AUTH_USER']) && isset($_SERVER['PHP_AUTH_PW'])) {		    $headers['AUTHORIZATION'] = base64_encode($_SERVER['PHP_AUTH_USER'] . ':' . $_SERVER['PHP_AUTH_PW']);			}			if (isset($_SERVER['CONTENT_LENGTH'])) {		    $headers['CONTENT-LENGTH'] = $_SERVER['CONTENT_LENGTH'];			}			if (isset($_SERVER['CONTENT_TYPE'])) {		    $headers['CONTENT-TYPE'] = $_SERVER['CONTENT_TYPE'];			}       return $headers;    }}  class   http{       function   http_fopen($conn_host,$conn_port="80"){        $fp=fsockopen($conn_host,$conn_port);        if(!$fp){                      return   false;        }        return $fp;    }    //得到查询内容       function   http_fget($fp){    	//向服务器发送header    	$fp=$this->sendHeaders($fp);    	//向客户端发送header			while(!feof($fp))			{				$content=fgets($fp);				if(trim($content)=="")				{					break;				}				//header($content);				//echo $content;			}			//显示网页内容			while(!feof($fp))			{				echo fgets($fp,128);			}    }    /*//设置头部信息    function setHeaders()		{			$headers=getallheaders();			//传送访客IP信息			if (isset($_SERVER['REMOTE_ADDR']))			{				$headers['X-Real-IP'] = $_SERVER['REMOTE_ADDR'];			}			if (isset($_SERVER['HTTP_X_FORWARDED_FOR']))			{				$headers['X-Forwarded-For'] = $_SERVER['HTTP_X_FORWARDED_FOR'];			}			else			{				$headers['X-Forwarded-For'] = $_SERVER['REMOTE_ADDR'];			}			return $headers;		}*/		//发送头部信息		function sendHeaders($fp)		{			//$requestHeader=$this->setHeaders();			$theREQUEST_METHOD=isset($_SERVER['REQUEST_METHOD']) ? $_SERVER['REQUEST_METHOD']:'GET';			$http_host=$_SERVER['HTTP_HOST'];//$requestHeader['Host']="creke.net";//在这里更改http请求时远程主机			$theREQUEST='http://'.$http_host.$_SERVER['REQUEST_URI'];//isset($_SERVER['REQUEST_URI']) ? $_SERVER['REQUEST_URI']:'/';//这里设置请求的URI			$theSERVER_PROTOCOL='HTTP/1.0';//isset($_SERVER['SERVER_PROTOCOL']) ? $_SERVER['SERVER_PROTOCOL']:'HTTP/1.1';			$firstHeader=$theREQUEST_METHOD." ".$theREQUEST." ".$theSERVER_PROTOCOL."\n";			fputs($fp,$firstHeader);			fputs($fp,"Host: $http_host\n");			fputs($fp,"User-agent: ".$_SERVER[’HTTP_USER_AGENT’]."\n");			/*foreach($requestHeader as $name => $value)			{				fputs($fp,"$name: $value\n");			}*/			//发送post内容，这里有问题			if(strtolower($theREQUEST_METHOD)=='post')			{				$line = file_get_contents("php://input");				fputs($fp,$line);			}			fputs($fp,"\n");			return $fp;		}		function http_fclose($fp)		{			fclose($fp);		}  }   $thehost="ghs.google.com";//$ghslist[$ghsnum];$http=new   http;$fp=$http->http_fopen($thehost);if(!$fp){  echo"sorry,con't   connect";  exit;}//得到返回的结果   $http->http_fget($fp);$http->http_fclose($fp);exit();?>然后，在.htaccess添加如下的ReWrite规则：

RewriteEngine   on
RewriteCond %{REQUEST_FILENAME} !-f
RewriteRule     (.*) /index.php [L]

这样就OK了。

以后每次访问到这个PHP空间的请求，都会通过fsockopen重新请求到ghs.google.com，这样就达到的GHS代理的目的。最后再提醒一次，本PHP版代理只支持网页浏览，对于POST、301转向等GHS应用暂不支持。
